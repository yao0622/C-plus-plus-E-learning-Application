<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    <title>派生类成员的标识与访问</title>
</head>
<body>
<h3>同名隐藏规则 </h3>
<p><br>
    当派生类与基类中有相同成员时： <br>
    若未强行指名，则通过派生类对象使用的是派生类中的同名成员。 <br>
    如要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名限定。</p>
<h3> <br>
    二义性问题 </h3>
<p><br>
    在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）??采用虚函数（参见第8章）或同名隐藏规则来解决。 <br>
    当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性??采用虚基类来解决。</p>
<h3> <br>
    二义性的解决方法 </h3>
<p><br>
    解决方法一：用类名来限定<br>
    c1.A::f() 或 c1.B::f()<br>
    解决方法二：同名隐藏<br>
    在C 中声明一个同名成员函数f()，f()再根据需要调用 A::f() 或 B::f()</p>
<h3>虚基类</h3>
<p> <br>
    虚基类的引入 <br>
    用于有共同基类的场合 <br>
    声明 <br>
    以virtual修饰说明基类<br>
    例：class  B1:virtual public B<br>
    作用 <br>
    主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.<br>
    为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝 <br>
    注意： <br>
    在第一级继承时就要将共同基类设计为虚基类。 <br>
    虚基类举例 <br>
    class B { public: int b; };<br>
    class B1: virtual public B { public: int  b1; };<br>
    class B2: virtual public B { public: int  b2; };<br>
    class C: public B1, public B2 { public:  float d; };</p>
<p>下面的访问是正确的： <br>
    C cobj;<br>
    cobj.b;</p>
<h3>虚基类及其派生类构造函数 </h3>
<p><br>
    建立对象时所指定的类称为最（远）派生类。 <br>
    虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。 <br>
    在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的默认构造函数。 <br>
    在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其他基类对虚基类构造函数的调用被忽略。 </p>
</body>
</html>