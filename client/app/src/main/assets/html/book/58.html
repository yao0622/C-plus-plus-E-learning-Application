<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    <title>异常处理</title>
</head>
<body>
<img src="images/knowledge-10.jpg" width="300"/>
<h3>理论目标</h3>
<p>在编写应用软件时，不仅要保证软件的正确性，还应该具有容错能力。在设计软件时，要充分考虑到各种意外情况，并给予适当的处理，要力争做到允许用户排除环境错误，继续运行程序，这就是异常处理。C++提供处理异常情况的内部支持，try, throw, catch语句就是C++语言用于实现异常处理的机制。<br>
    为了加强程序的可读性，使用户能够方便地知道所使用的函数会抛掷哪些异常，可以在函数的声明中列出可能抛掷的所有异常类型，这就是异常接口声明。<br>
    C++异常处理不仅能够处理各种不同类型的异常，还具有在栈解旋（unwinding）期间为异常抛掷前构造的所有局部对象自动调用析构函数的能力。
</p>
本章的主要学习目标包括： <br>
<li>	理解异常处理的基本思想，熟悉异常处理的实现过程，掌握异常处理的基本语法(try, throw, catch)和编程方法。</li>
<li>      掌握异常接口声明的方法，理解异常处理中的构造与析构过程。</li><br>

<h3>实践目标</h3>

<li>	熟练掌握异常处理的基本编程方法；</li>
<li>	掌握异常接口编程方法。</li></p>

<h3>知识点：</h3>
<p>（1）异常处理的基本思想<br>
    （2）异常处理的实现方法<br>
    （3）异常接口声明<br>
    （4）异常处理中的构造与析构</p>

<h3>重点：</h3>
<p>（1）异常处理的编程实现方法<br>
    （2）异常接口的声明方法</p>

<h3>难点：</h3>
<p>（1）理解异常处理中的构造与析构</p>
<br>
<br />
</h3>
</p>
</p>

<h3>异常处理的基本思想</h3>
<p>在大型软件中，由于函数之间有着明确的分工和复杂的调用关系，发现错误的函数往往不具备处理错误的能力。这时它可以引发一个异常，希望它的调用者能够捕获这个异常并处理这个错误。如果调用者也不能处理这个错误，还可以继续传递给上级调用者去处理，这种传播会一直继续到异常被处理为止。如果程序始终没有处理这个异常，最终它会被传到C++运行系统那里，运行系统捕获异常后通常会简单地终止程序。但轻易不会出现死机，一般不会出现灾难性的后果。</p>

<h3>异常处理的实现</h3>
try，throw，catch语句就是C++语言提供对处理异常情况的语句。<br>
抛掷异常的方式：<br>
throw 表达式；<br>
捕获并处理异常的方式：<br>
try<br>
复合语句<br>
catch（异常声明）<br>
复合语句<br>
catch（异常声明）<br>
复合语句<br>
…<br>
<p>异常处理的执行过程如下：<br>
    （1）程序通过正常的执行顺序到达try语句，然后执行try块内的保护段。<br>
    （2）如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行。程序从异常被抛掷的try块后跟随的最后一个catch子句后面的语句继续执行下去。<br>
    （3）程序执行到一个throw表达式时，一个异常对象会被创建。若异常的抛出点本身在一个try子句内，则该try语句后的catch子句会按顺序检查异常类型是否与声明的类型匹配；若异常抛出点本身不在任何try子句内，或抛出的异常与各个catch子句所声明的类型都不匹配，则结束当前函数的执行，回到当前函数的调用点，把调用点作为异常的抛出点，然后重复这一过程。此处理继续下去，直到异常成功被一个catch语句捕获。<br>
    （4）如果始终没有找到与被抛掷异常匹配的catch子句，最终main函数会结束执行，则运行库函数terminate将被自动调用，其terminate的默认功能是调用abort终止程序。<br>
    （5）如果找到了一个匹配的catch子句，则catch子句后的复合语句会被执行。复合语句执行完毕后，当前的try块（包括try子句和一系列catch子句）即执行完毕。<br>

<h3>异常接口声明</h3>
<p>为了加强程序的可读性，使函数的用户能够方便地知道所使用的函数会抛掷哪些异常，可以在函数的声明中列出这个函数可能抛掷的所有的异常类型。例如：<br>
    void fun() throw(A, B, C, D);<br>
    表明函数fun()能且仅能抛掷类型A, B, C, D及其子类型的异常。<br>
    如果在函数的声明中没有包括异常接口声明，则此函数可以抛掷任何类型的异常。例如：<br>
    void fun();<br>
    一个不抛掷任何类型异常的函数可以进行如下形式的声明：<br>
    void fun() throw();<br></p>

<h3>异常处理中的构造与析构</h3>
<p>异常被抛出后，从进入try块（与截获异常的catch子句相对应的那个try块）起，到异常被抛掷前，这期间在栈上构造且尚未析构的所有对象都会被自动析构，析构的顺序与构造的顺序相反。这一过程称为栈的解旋（unwinding）。</p>
</body>
</html>