<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    <title>继承与派生</title>
</head>
<body>
<img src="image/knowlege-7.jpg" width="466" height="142">
<h3>理论目标 </h3>
<p>类的继承允许程序员在保持原有类的特性的基础上，进行更具体、更详细的类的定义。以原有的类为基础产生新的类，我们就说新类继承了原有类的特征，也可以说从原有类派生出新类。 </p>
<p>通过类的派生机制，可以提高代码的重用性和可扩充性。软件开发完成后，当问题有了新的发展或对问题有了新的认识时，也能高效地改造和扩充已有的软件。由此可知，通过继承和派生的机制，对于已有程序的发展和改进，是极为有利的。 </p>
<p>派生新类的过程包括吸收已有类的成员、调整已有类的成员和添加新的成员3个步骤。围绕派生过程，我们重点讨论不同继承方式下的基类成员的访问控制、添加构造函数、析构函数，还要学习类成员的唯一标识和访问问题。 </p>
<p> 本章的主要学习目标包括： </p>
<p>
<li>理解什么是继承关系，理解派生类的概念，掌握派生类的定义方法；掌握派生类的生成过程。 </li>
<li>理解类成员的访问控制的概念，理解不同继承方式的影响主要体现在哪些方面，掌握公有继成、私有继承、保护继承各自的特点和声明方法。 </li>
<li>理解兼容规则的定义，掌握兼容规则中替代的几种情况。 </li>
<li>理解派生类的构造函数和析构函数，掌握派生类构造函数的使用方法，明白声明派生类构造函数的时机，掌握派生类构造函数执行的一般次序，掌握编写复制构造函数的方法，掌握派生类析构函数的执行次序。 </li>
<li>理解唯一标识问题，掌握作用域分辨符的使用方法，理解隐藏规则，理解虚基类的概念，掌握虚基类及其派生类构造函数的使用方法。 </li>
</br></p>
<h3 >实践目标 </h3>
<p>
<li>熟练掌握继承和派生类的定义和使用方法； </li>
<li>熟练掌握公共继承、私有继承、保护继承之间的区别和使用方法； </li>
<li>掌握派生类的构造函数和析构函数的执行次序； </li>
<li>掌握作用域分辨符的使用方法、虚基类的定义和使用方法。 </li>
</p>

<h3 >知识点：</h3>
<p ><br />
    （1）继承和派生类的概念与定义（包括：单继承、多继承） <br />
    （2）派生类生成过程（包括：吸收基类成员、改造基类成员、添加新的成员） <br />
    （3）访问控制的方式（包括：公有继承、私有继承、保护继承） <br />
    （4）类型兼容规则 <br />
    （5）公有派生类的对象替代基类对象的几种情况 <br />
    （6）派生类构造函数的语法形式 <br />
    （7）派生类构造函数执行的一般次序 <br />
    （8）复制构造函数的编写 <br />
    （9）派生类析构函数工作机理 <br />
    （10）派生类成员标识和访问 <br />
    （11）不同作用域声明的标识符的隐藏规则 <br />
    （12）虚基类的定义和使用方法 <br />
    （13）虚基类及其派生类构造函数 </p>
<h3 >重点： </h3>
<p ><br />
    （1）继承和派生类的概念与定义（包括：单继承、多继承） <br />
    （2）派生类生成过程（包括：吸收基类成员、改造基类成员、添加新的成员） <br />
    （3）访问控制的方式（包括：公有继承、私有继承、保护继承） <br />
    （4）公有派生类的对象替代基类对象的几种情况 <br />
    （5）派生类构造函数的语法形式 <br />
    （6）派生类构造函数执行的一般次序 <br />
    （7）派生类析构函数工作机理 <br />
    （8）不同作用域声明的标识符的隐藏规则 <br />
    （9）虚基类的定义和使用方法 </p>
<h3 >难点： </h3>
<p ><br />
    （1）理解继承和派生类的概念 <br />
    （2）理解公有继承、私有继承、保护继承之间的区别 <br />
    （3）公有派生类的对象替代基类对象的几种情况 <br />
    （4）复制构造函数的编写 <br />
    （5）虚基类及其派生类构造函数 </p>

<p align="left"><strong>类的继承与派生 </strong><br />
    保持已有类的特性而构造新类的过程称为继承。 <br />
    在已有类的基础上新增自己的特性而产生新类的过程称为派生。 <br />
    被继承的已有类称为基类（或父类）。 <br />
    派生出的新类称为派生类。 <br />
    <strong>继承与派生的目的 </strong><br />
    继承的目的：实现代码重用。 <br />
    派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。 <br />
    <strong>派生类的声明</strong><br />
    定义格式：<br />
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;class 派生类名：继承方式 基类名 <br />
    {<br />
    成员声明； <br />
    }</p>
<p align="left"><strong>继承方式 </strong><br />
    不同继承方式的影响主要体现在：派生类成员对基类成员的访问权限和通过派生类对象对基 <br />
    类成员的访问权限。 <br />
    三种继承方式：公有继承、私有继承、保护继承 <br />
    <strong>公有继承(public)</strong><br />
    （1）基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可直接访问。 <br />
    （2）派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。 <br />
    （3）通过派生类的对象只能访问基类的public成员。 <br />
    <strong>私有继承(private)</strong><br />
    （1）基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可直接访问。 <br />
    （2）派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。 <br />
    （3）通过派生类的对象不能直接访问基类中的任何成员。 </p>
<p align="left"><strong>保护继承(protected)</strong><strong> </strong><br />
    （1）基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可直接访问。 <br />
    （2）派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。 <br />
    （3）通过派生类的对象不能直接访问基类中的任何成员 <br />
    保护继承的特点：对建立其所在类对象的模块来说，它与 private 成员的性质相同；对于其派生类来说，它与 public 成员的性质相同；既实现了数据隐藏，又方便继承，实现代码重用。 <br />
    <strong>类型兼容规则 </strong><br />
    一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在：派生类 <br />
    的对象可以隐含转换为基类对象；派生类的对象可以初始化基类的引用；派生类的指针可以 <br />
    隐含转换为基类的指针。 <br />
    通过基类对象名、指针只能使用从基类继承的成员。 <br />
    <strong>基类与派生类的对应关系</strong><br />
    单继承：派生类只从一个基类派生。 <br />
    多继承：派生类从多个基类派生。 <br />
    多重派生：由一个基类派生出多个不同的派生类。 <br />
    多层派生：派生类又作为基类，继续派生新的类。 <br />
    <strong>多继承时派生类的声明</strong> <br />
    定义方式： <br />
    class 派生类名：继承方式1 基类名1，<br />
    继承方式2 基类名2，...<br />
    {<br />
    成员声明； <br />
    }<br />
    注意：每一个“继承方式”，只用于限制对紧随其后之基类的继承。 <br />
    <strong>继承时的构造函数 </strong><br />
    基类的构造函数不被继承，派生类中需要声明自己的构造函数。定义构造函数时，只需要对 <br />
    本类中新增成员进行初始化，对继承来的基类成员的初始化，自动调用基类构造函数完成。 <br />
    派生类的构造函数需要给基类的构造函数传递参数。 <br />
    单一继承时构造函数定义方式： <br />
    派生类名::派生类名(基类所需的形参，本类成员所需的形参):基类名(参数表)<br />
    {<br />
    本类成员初始化赋值语句； <br />
    }； <br />
    多继承时构造函数定义方式： <br />
    派生类名::派生类名(参数表):基类名1(基类1初始化参数表), 基类名2(基类2初始化参数表), ...基类名n(基类n初始化参数表)<br />
    {<br />
    本类成员初始化赋值语句； <br />
    }； <br />
    <strong>构造函数的执行顺序 </strong><br />
    1． 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。 <br />
    2． 对成员对象进行初始化，初始化顺序按照它们在类中声明的顺序。 <br />
    3．执行派生类的构造函数体中的内容。 <br />
    <strong>拷贝构造函数 </strong><br />
    若建立派生类对象时没有编写拷贝构造函数，编译器会生成一个隐含的拷贝构造函数，该函数先调用基类的拷贝构造函数，再为派生类新增的成员对象执行拷贝。 <br />
    若编写派生类的拷贝构造函数，则需要为基类相应的拷贝构造函数传递参数。例如:<br />
    C::C(C &amp;c1):  B(c1) {…}<br />
    <strong>继承时的析构函数 </strong><br />
    析构函数也不被继承，派生类自行声明，声明方法与一般（无继承关系时）类的析构函数相同。不需要显式地调用基类的析构函数，系统会自动隐式调用。析构函数的调用次序与构造函数相反。 <br />
    <strong>同名隐藏规则 </strong><br />
    当派生类与基类中有相同成员时： <br />
    若未强行指名，则通过派生类对象使用的是派生类中的同名成员。 <br />
    如要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名限定。 <br />
    <strong>二义性问题 </strong><br />
    在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）??采用虚函数（参见第8章）或同名隐藏规则来解决。 <br />
    当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性??采用虚基类来解决。 <br />
    二义性问题解决方法： <br />
    解决方法一：用类名来限定 c1.A::f() 或 c1.B::f() 。 <br />
    解决方法二：同名隐藏 <br />
    在C 中声明一个同名成员函数f()，f()再根据需要调用 A::f()或B::f() 。 <br />
    <strong>虚基类 </strong><br />
    虚基类的引入：用于有共同基类的场合 <br />
    声明：以virtual修饰说明基类。例：class B1:virtual public B<br />
    作用：主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题。为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝。 <br />
    注意：在第一级继承时就要将共同基类设计为虚基类。 <br />
    <strong>虚基类及其派生类构造函数 </strong><br />
    建立对象时所指定的类称为最（远）派生类。 <br />
    虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。 <br />
    在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的默认构造函数。 <br />
    在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其他基类对虚基类构造函数的调用被忽略。 </p>
</body>
</html>