<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    <title>指针</title>
</head>
<body>
<p>对内存空间的访问有两种方式：通过变量名和地址。<br/>
    &nbsp; &nbsp; 具有静态生存期的变量在程序开始运行之前就已经被分配了内存空间；具有动态生存期的变量在程序运行时遇到变量声明语句时被分配内存空间的。在获得内存空间的同时，变量名就成了相应内存空间的名称，可以通过变量名直接存取变量内容。<br/>
    &nbsp; &nbsp;  如果变量名不够方便或者没有变量名可用（如动态分配的内存）时，需要直接使用地址访问内存单元。</p>
<p>指针是一种数据类型，专门用来存放内存单元地址的，具有指针类型的变量称为指针变量。指针可以指向各种类型，包括基本类型、数组（数组元素）、函数、对象，同样也可以指向指针。</p>
<p>通过变量名访问一个变量是直接的，而通过指针访问一个变量时间接地。</p>
<p>指针也是先声明后使用。<br/>
    声明指针的语法形式： 数据类型 *标识符 （此时指针未赋值，地址值是一个不确定的数）；<br/>
    指针的赋值语法形式：指针名=地址<br/>
    &nbsp; &nbsp;&nbsp;  注意事项<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;   --“地址”中存放的数据类型与指针类型必须相符。<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; --向指针变量赋的值必须是地址常量或变量，不能是普通整数。但可以赋值为整数0，表示空指针。<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; --指针的类型是它所指向变量的类型，而不是指针本身数据值的类型，任何一个指针本身的数据值都 <br/>&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;是unsigned long int型。<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; --允许声明指向 void 类型的指针，该指针可以被赋予任何类型对象的地址<br>

    初始化指针的语法形式： 存储类型 数据类型 *指针名＝初始地址；<br/>
    &nbsp; &nbsp;&nbsp;注意事项<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;?用变量地址作为初值时，该变量必须在指针初始化之前已说明过，且变量类型应与指针类型一致。<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;?可以用一个已赋初值的指针去初始化另一个指针变量。<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;?不要用一个内部 auto 变量去初始化 static 指针。</p>

&nbsp; &nbsp;C++提供了两个与地址相关的一元运算符----指针运算符“*”和取地址运算符“&”；注意的是这两种运算符出现在声明语句和执行语句中的含义是不同的：<br/>
&nbsp; &nbsp;“*” ：在声明语句中，放在被声明的变量名之前，表示声明的是指针。<br/>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;例 int *p; //声明p 是一个int型指针<br/>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;在执行语句中或者初始化表达式中时，表示访问指针所指对象的内容。</br>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;例 cout<< *p;<br/>
&nbsp; &nbsp;“&”：在声明语句中时，表示声明的是引用<br/>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;例 int &rf; //声明一个int型的引用rf<br/>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;给变量赋初值时出现在等号右边或在执行语句中作为一元运算符出现时，表示取对象的地址<br/>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;例 pa=&a; //将a的地址赋给pa;</p>
<p>关于指针的类型，应注意一下几点：<br/>
    &nbsp; &nbsp;（1）指向常量的指针：不能通过指针来改变所指对象的值，但指针可以改变指向另外的对象<br/>
    &nbsp; &nbsp;（2）指针类型的常量：指针本身的值不能改变。<br/>
    &nbsp; &nbsp;（3）Void类型指针：可以存储任何类型的对象的地址，通过类型显式转换可以访问任何类型的数据。</p>
<p>指针是一种数据类型，可以参加部分运算，包括算术运算、关系运算和赋值运算。<br/>
    算术运算：指针p加上或减去n，其意义是指针当前指向位置的前方或后方第n个数据的地址。<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;*(p+n)=p[n]    *(p-n)=p[-n]<br/>
    关系运算：是指相同类型的指针之间进行的关系运算；不同类型的指针之间或指针与非0整数之间的关系运算是无意义的；指针可以和零之间进行等于或不等于的关系运算。<br/>
    赋值运算：向指针变量赋的值必须是地址常量或变量，不能是普通整数。但可以赋值为整数0，表示空指针</p>
<p>指针的算术运算一般是和数组的使用相联系的，只有使用数组时才能获得连续分布的可操作内存空间。对于一个独立变量的地址，容易发生地址越界错误，因此指针的算术运算要慎用。如果对一个指针不便于用一个有效地址赋值，应该赋予初值0。</p>
<p>可以使用指针来对数组及其元素进行方便而快速的操作，指向数组元素指针的声明、赋值、引用：<br/>
    &nbsp; &nbsp;声明与赋值<br/>
    &nbsp; &nbsp;例：int a[10], *pa;<br/>
    &nbsp; &nbsp;pa=&a[0]; 或 pa=a;<br/>
    &nbsp; &nbsp;通过指针引用数组元素<br/>
    &nbsp; &nbsp;经过上述声明及赋值后：<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;?*pa就是a[0]，*(pa+1)就是a[1]，... ，*(pa+i)就是a[i].<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;?a[i], *(pa+i), *(a+i), pa[i]都是等效的。<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;?不能写 a++，因为a是数组首地址是常量。 <br/>
    注：把数组作为函数的形参等价于把指向数组元素类型的指针作为形参。</p>
<p>指针数组：一个数组的每个元素都是指针变量，指针数组的每个元素都必须是同一类型的指针。<br/>
    声明一维指针数组的语法形式为：<br/>
    &nbsp; &nbsp;数据类型 *数组名[下标表达式]<br/>
    &nbsp; &nbsp;例：Point  *pa[2];<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;由pa[0],pa[1]两个指针组成 </p>
<p>指针作为函数形参有三个作用：<br/>
    （1）	实参和形参指针指向共同的内存空间，达到参数双向传递的目的。<br/>
    （2）	减少函数调用时数据传递的开销。<br/>
    （3）	通过指向函数的指针传递函数代码的首地址。<br/>
    注：如果函数体中不需要通过改变指针所指向对象的内容，应在参数表中将其声明为指向常量的指针，这样使得常对象被取地址后也可以作为该函数的参数。</p>
</p>指针型函数：函数的返回值是指针类型。使用指针型函数的目的就是要在函数结束后把大量的数据从被调函数返回到主调函数中，而通常非指针型函数调用结束后，只能返回一个变量或者对象。<br/>
&nbsp; &nbsp;一般定义形式：数据类型 *函数名（参数表）<br/>
&nbsp; &nbsp;&nbsp; &nbsp;{<br/>
&nbsp; &nbsp;&nbsp; &nbsp;函数体<br/>
&nbsp; &nbsp;&nbsp; &nbsp;}<br/>
数据类型表明函数返回指针的类型；函数和“*”表示了一个指针型的函数；参数表中是函数的形参列表。</p>
<p>指向函数的指针：专门用来存放函数代码首地址的变量。数据指针指向数据存储区，而函数指针指向的是程序代码存储区。当函数指针指向了某个函数，它与函数名都可以调用函数。<br/>
    声明一个函数指针时，也需要说明函数的返回值、形式参数列表：<br/>
    &nbsp; &nbsp;数据类型（*函数指针名）（形参表）<br/>
    赋值：函数指针名=函数名； <br/>
    等号右边的函数名所指出的必须是一个已经存在的函数代码的真实地址，赋值之后可以通过指针名直接引用该函数。<br/>
    注：如果在程序中出现对此类型指针多次重复的定义可以使用typedef:<br/>
    例：typedef int （*DoubleIntFunction）（double）;<br/>
    声明了DoubleIntFunction为“一个double形参、返回类型为int的函数的指针”类型的别名。以后可以直接使用，DoubleIntFunction funcPtr;</p>
<p>对象指针：对象指针就是用于存放对象地址的变量。可以通过对象名和对象地址来访问一个对象。<br/>
    声明对象指针的一般语法形式为：<br/>
    &nbsp; &nbsp;类名 *指针名；<br/>
    像通过对象名来访问对象的成员一样，使用对象指针可以方便访问对象的成员，语法形式为： <br/>
    &nbsp; &nbsp;对象指针名->成员名   =  （*对象指针名）.成员名</p>
<p>this指针是一个隐含于每一个非静态成员函数中的特殊指针（包括构造函数和析构函数），它用于指向正在被成员函数操作的对象，*this表示正在调用的该函数的对象。<br/>
    &nbsp; &nbsp;例如：Point类的getX函数中的语句：<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;return x;<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;相当于：<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;return this->x;<br/>
    注：当局部作用域中存在于类成员同名的标识符时，可以通过this指针访问该类成员。</p>
<p>指向类的非静态成员指针：直接指向对象成员的指针。<br/>
    &nbsp; &nbsp;通过指向成员的指针只能访问公有成员<br/>
    &nbsp; &nbsp;声明指向成员的指针：<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;声明指向公有数据成员的指针<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;类型说明符  类名::*指针名;<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;声明指向公有函数成员的指针<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;类型说明符  (类名::*指针名)(参数表)；<br/>
    &nbsp; &nbsp;对指向类的非静态成员指针赋值以及访问的一般语法形式：<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;指向数据成员的指针<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;?说明指针应该指向哪个成员<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; 指针名 = &类名::数据成员名；<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;?通过对象名（或对象指针）与成员指针结合来访问数据成员<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; 对象名.*类成员指针名<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;或;<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 对象指针名->*类成员指针名<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;指向函数成员的指针<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;?初始化<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 指针名=&类名::函数成员名；<br/>
    &nbsp; &nbsp;&nbsp; &nbsp;- 通过对象名（或对象指针）与成员指针结合来访问函数成员<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;(对象名.*类成员指针名)(参数表)<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;或：<br/>
    &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;(对象指针名->*类成员指针名)(参数表)<br/>
    注：对类成员取地址时，也要遵守访问权限的约定，即在一个类的作用域之外不能够对它的私有成员取地址。</p>
<p>对类的静态成员的访问时不依赖于对象的，因此可以通过普通的指针来指向和访问静态成员。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><BR>
</p>
</body>
</html>