<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    <title>派生类的构造和析构函数</title>
</head>
<body>
<style type="text/css">
    <!--
    .STYLE1 {color: #FF0000}
    -->
</style>
<h2>派生类的构造函数和析构函数 </h2>

<h3>1.派生类的构造函数 </h3>
<p>派生类名（总参数列表）: 基类名（参数列表1），子对象名1（参数列表2），子对象名2（参数列表3），… <br>
    { <br>
    派生类中新增数据成员的初始化语句 <br>
    }<br>
    执行构造函数的顺序是：派生类构造函数先调用基类的构造函数，对基类数据成员初始化，再执行派生类构造函数本身，对派生类数据成员初始化。 <br>
    包含子对象的派生类构造函数的执行顺序是：派生类构造函数先调用基类的构造函数，对基类数据成员初始化；再调用子对象构造函数，对子对象数据成员初始化，最后执行派生类构造函数本身，对派生类数据成员初始化。 </p>
<h3><br>
    2.拷贝构造函数 </h3>
<p><br>
    若建立派生类对象时没有编写拷贝构造函数，编译器会生成一个隐含的拷贝构造函数，该函数先调用基类的拷贝构造函数，再为派生类新增的成员对象执行拷贝。 <br>
    若编写派生类的拷贝构造函数，则需要为基类相应的拷贝构造函数传递参数。例如:<br>
    C::C(C &amp;c1): B(c1) {…}</p>
<h3><br>
    3.派生类的析构函数 </h3>
<p><br>
    派生类析构函数没有函数类型、没有参数，其定义及使用方法与一般类的析构函数相同。派生类的析构函数用来对派生类中所增加的成员进行清理工作，同时系统会自动调用基类的析构函数和子对象的析构函数，对基类和子对象进行清理。 <br>
    析构函数的调用顺序与构造函数正好相反：先执行派生类的析构函数，然后调用子对象的析构函数，最后调用基类的析构函数，对基类进行清理。 </p>
</body>
</html>